---
In: UnrealEngine
title: "Unreal Engine Object Lifecycle and Animation Architecture"
author: "Gemini"
---

# Unreal Engine: Object Lifecycle and Animation Architecture

언리얼 엔진에서 살아 숨 쉬는 캐릭터를 만들기 위해서는, 그 기반이 되는 오브젝트 시스템의 작동 방식을 이해하는 것이 필수적입니다. 모든 것은 가장 기본적인 `UObject`에서 시작하여, 월드에 존재하는 `Actor`와 그 기능을 확장하는 `Component`로 구체화됩니다. 그리고 이 구조 위에서 비로소 `Animation` 시스템이 동작하여 캐릭터에 생명을 불어넣습니다.

이 가이드는 언리얼의 가장 근본적인 오브젝트 생명주기(Lifecycle)부터 시작하여, 최종적으로 애니메이션 시스템이 어떻게 유기적으로 결합되는지 그 전체적인 아키텍처를 심도 있게 탐구합니다.

## 1부: 모든 것의 근원, UObject와 생명주기

`UObject`는 언리얼 엔진의 모든 클래스의 최상위 기본 클래스입니다. 이는 다음과 같은 핵심 시스템의 기반을 제공합니다.

- **리플렉션(Reflection)**: 런타임에 클래스의 속성과 함수를 동적으로 파악하고 조작합니다.
- **가비지 컬렉션(Garbage Collection)**: 더 이상 참조되지 않는 `UObject`의 메모리를 자동으로 해제합니다.
- **시리얼라이제이션(Serialization)**: 오브젝트의 상태를 디스크에 저장하거나 네트워크로 전송합니다.

### UObject 라이프사이클

1.  **생성(Creation)**: `NewObject<UYourClass>()` 등을 통해 인스턴스화됩니다.
2.  **초기화(Initialization)**: `PostInitProperties()`(속성 초기화 후), `PostLoad()`(디스크에서 로드 후) 등이 호출됩니다.
3.  **소멸(Destruction)**: 아무 곳에서도 참조되지 않으면 가비지 컬렉터에 의해 수집됩니다. `BeginDestroy()`가 호출되어 소멸 과정을 시작하고, `FinishDestroy()`로 마무리됩니다.

## 2부: 월드의 구성 단위, Actor와 Component

`Actor`와 `Component`는 `UObject`를 상속받아 게임 월드를 구성하는 실질적인 단위입니다.

- **`AActor`**: 월드에 배치될 수 있는 독립적인 개체입니다. 고유한 위치, 회전, 크기(`Transform`)를 가집니다. 캐릭터, 아이템, 광원 등 월드에 존재하는 모든 것이 액터입니다.
- **`UActorComponent`**: 액터에 부착되어 특정 기능(모양, 움직임, 능력 등)을 제공하는 모듈식 부품입니다. 컴포넌트는 재사용이 가능하여 효율적인 개발을 돕습니다.

### Actor와 Component의 라이프사이클

액터의 생명주기는 `UObject`보다 더 구체적이며, 게임플레이와 밀접하게 연관됩니다. 컴포넌트는 자신을 소유한 액터의 라이프사이클에 종속됩니다.

| 단계 | 주요 함수 (호출 순서) | 역할 및 설명 |
| --- | --- | --- |
| **생성/스폰** | `OnConstruction` | 액터가 생성될 때(에디터, 런타임) 호출됩니다. 블루프린트의 생성자 스크립트가 실행되는 시점입니다. |
| **초기화** | `PreInitializeComponents` | 컴포넌트들이 초기화되기 직전에 호출됩니다. |
| | `InitializeComponent` | 각 **컴포넌트**가 스스로를 초기화하는 함수입니다. |
| | `PostInitializeComponents` | 모든 컴포넌트의 초기화가 완료된 후 호출됩니다. 컴포넌트 간의 참조 설정에 유용합니다. |
| | **`BeginPlay`** | **가장 중요한 초기화 함수.** 액터가 월드에 완전히 진입하여 게임플레이를 시작할 준비가 되었을 때 호출됩니다. 대부분의 게임 로직은 여기서 시작됩니다. |
| **업데이트** | **`Tick` / `TickComponent`** | 매 프레임 호출되어 시간의 흐름에 따른 로직을 처리합니다. 성능에 민감하므로 필요할 때만 사용해야 합니다. |
| **소멸** | **`EndPlay`** | 액터가 월드에서 제거되기 직전에 호출됩니다. `BeginPlay`에서 설정했던 것들을 정리(Cleanup)하는 가장 중요한 곳입니다. |
| | `Destroyed` | `EndPlay` 이후, 액터가 실제로 소멸되기 직전에 마지막으로 호출됩니다. |

## 3부: 생명을 불어넣는 기술, 애니메이션 아키텍처

애니메이션 시스템은 위에서 설명한 액터/컴포넌트 구조 위에서 동작합니다. `ACharacter`는 `SkeletalMeshComponent`를 기본으로 포함하며, 이 컴포넌트가 애니메이션 시스템의 핵심입니다.

### 3.1. 애니메이션 시스템의 핵심 구성 요소

언리얼 엔진의 애니메이션은 여러 요소들이 유기적으로 결합하여 작동합니다. 각 요소의 역할과 관계를 이해하는 것이 중요합니다.

- **`USkeletalMeshComponent`**: 애니메이션 시스템의 심장과도 같은 역할을 합니다. 이 컴포넌트는 3D 모델(Skeletal Mesh)과 애니메이션 블루프린트를 담고 있으며, 최종적으로 계산된 포즈를 렌더링하는 책임을 집니다. 모든 애니메이션 로직은 이 컴포넌트를 중심으로 실행됩니다.

- **`USkeleton`**: 뼈대의 계층 구조를 정의합니다. 이는 3D 모델과 애니메이션 데이터를 연결하는 '청사진' 역할을 하며, 서로 다른 모델이라도 동일한 `USkeleton`을 공유한다면 애니메이션을 재사용할 수 있게 해주는 **애니메이션 공유의 핵심**입니다.

- **`UAnimInstance`**: `USkeletalMeshComponent`마다 하나씩 존재하는 인스턴스로, 애니메이션의 '뇌'라고 할 수 있습니다. 실제 애니메이션 로직이 실행되는 곳이며, C++ 코드에서는 `UAnimInstance`를 통해 애니메이션 블루프린트의 변수를 업데이트하거나 몽타주를 재생하는 등 직접적인 제어를 수행합니다.

- **`UAnimBlueprint`**: `UAnimInstance`의 구체적인 로직을 시각적으로 디자인하는 에셋입니다. 이벤트 그래프와 애님 그래프라는 두 개의 주요 부분으로 나뉘어, 데이터 처리와 로직 실행을 분리합니다.

### 3.2. 데이터의 흐름: 이벤트 그래프와 애님 그래프

애니메이션 블루프린트는 데이터의 입력과 처리를 담당하는 두 개의 그래프로 구성되어, 명확하고 효율적인 구조를 가집니다.

#### 이벤트 그래프 (Event Graph): 데이터 입력부

- **역할**: 게임 월드로부터 필요한 데이터를 수집하여 애님 그래프에서 사용할 변수를 준비하는 역할을 합니다.
- **실행 시점**: 매 프레임 `USkeletalMeshComponent`의 `Tick`과 함께 `Event Blueprint Update Animation` 노드가 실행됩니다.
- **주요 로직**:
    - `Try Get Pawn Owner`: 이 노드를 통해 `UAnimInstance`가 소속된 `ACharacter` 또는 `APawn`의 참조를 얻습니다.
    - **데이터 가져오기**: 캐릭터의 현재 속도, 가속도, 점프 여부, 특정 스킬 사용 여부 등 게임플레이에 필요한 모든 데이터를 가져와 변수에 저장합니다. 이 변수들은 애님 그래프에서 실시간으로 사용됩니다.

#### 애님 그래프 (Anim Graph): 로직 처리 및 출력부

- **역할**: 이벤트 그래프에서 준비된 데이터를 바탕으로, 최종적으로 캐릭터가 취할 포즈를 계산하고 조합하는 역할을 합니다.
- **구조**: 다양한 노드들을 연결하여 복잡한 애니메이션 로직을 만듭니다. 최종 결과는 `Output Pose` 노드로 출력됩니다.
- **주요 노드 및 기능**:
    - **상태 머신 (State Machines)**: 'Idle', 'Walk', 'Jump' 등 캐릭터의 명확한 상태를 정의하고, 상태 간의 전환 규칙(Transition Rule)을 설정합니다. 예를 들어, '속도가 0보다 크면 Idle에서 Walk로 전환'과 같은 규칙을 만듭니다.
    - **블렌드 스페이스 (Blend Spaces)**: 속도나 방향과 같은 연속적인 값에 따라 여러 애니메이션(예: 서기 → 걷기 → 뛰기)을 부드럽게 섞어줍니다. 이를 통해 적은 수의 애니메이션으로도 자연스러운 움직임을 표현할 수 있습니다.
    - **애니메이션 몽타주 (Animation Montage)**: 상태 머신의 흐름과 독립적으로, 특정 애니메이션(주로 공격, 스킬 사용, 리액션 등)을 우선적으로 재생시키는 시스템입니다. C++ 코드나 다른 블루프린트에서 `Montage_Play` 함수를 호출하여 직접 제어할 수 있습니다.
    - **레이어 블렌딩 (Layered Blending)**: 상체와 하체의 애니메이션을 분리하여 조합할 수 있게 해줍니다. 예를 들어, 뛰면서 상체만 공격하는 애니메이션을 구현할 때 사용됩니다.

### 3.3. 전체 시스템의 유기적 워크플로우

1.  **초기화**: 게임이 시작되고 캐릭터가 스폰되면, `USkeletalMeshComponent`는 지정된 `UAnimBlueprint`를 기반으로 `UAnimInstance`를 생성합니다. (`BeginPlay` 시점)
2.  **데이터 수집 (매 프레임)**:
    a. 캐릭터의 `Tick` 함수가 실행됩니다.
    b. `UAnimInstance`의 **이벤트 그래프**가 업데이트되어, 캐릭터의 현재 속도, 방향, 상태 등의 변수를 최신화합니다.
3.  **로직 처리 (매 프레임)**:
    a. **애님 그래프**는 이벤트 그래프에서 업데이트된 변수들을 사용하여 상태 머신, 블렌드 스페이스 등 다양한 노드를 거쳐 최종 포즈를 계산합니다.
4.  **포즈 출력**:
    a. 계산된 최종 포즈가 `Output Pose`를 통해 `USkeletalMeshComponent`로 전달됩니다.
    b. `USkeletalMeshComponent`는 이 포즈를 기반으로 `USkeletalMesh`를 화면에 렌더링합니다.
5.  **이벤트 기반 제어**:
    a. 플레이어가 공격 버튼을 누르면, 캐릭터의 C++ 코드는 `AnimInstance->Montage_Play(AttackMontage)`와 같은 함수를 호출합니다.
    b. 애님 그래프는 현재 상태 머신의 로직을 잠시 멈추고, 지정된 몽타주를 최우선으로 재생합니다. 몽타주 재생이 끝나면 다시 상태 머신의 로직으로 복귀합니다.
6.  **소멸**: 캐릭터가 월드에서 제거되면 `EndPlay` 라이프사이클 이벤트가 실행되어 모든 것을 정리합니다.

이처럼 언리얼 엔진은 `UObject`라는 단단한 기반 위에 `Actor`와 `Component`라는 유연한 구조를 세우고, 그 위에서 데이터(이벤트 그래프)와 로직(애님 그래프)을 명확히 분리한 `Animation` 시스템이 유기적으로 동작하도록 설계되어 있습니다. 이 통합된 아키텍처를 이해하는 것은 복잡하고 생동감 넘치는 캐릭터를 체계적으로 구현하는 첫걸음입니다.