---
In: UnrealEngine
title: "Unreal Engine Animation System Architecture"
author: "Gemini"
---

언리얼 엔진의 애니메이션 시스템은 단순한 기능의 집합이 아닌, 데이터, 로직, 표현이 유기적으로 결합된 정교한 아키텍처입니다. 이 문서는 각 구성 요소가 어떤 역할을 하며 어떻게 상호작용하여 최종적으로 살아 숨 쉬는 캐릭터를 만들어내는지, 그 핵심 철학을 중심으로 심도 있게 분석합니다.

### 1부: 애니메이션의 구성 요소 (The Assets)

모든 애니메이션은 데이터를 담고 있는 애셋에서 시작됩니다. 이 애셋들은 애니메이션을 구성하는 가장 기본적인 '재료'입니다.

#### 1.1. `Skeletal Mesh` & `Skeleton`: 움직임의 기반
- **`Skeleton`:** 캐릭터의 모든 움직임을 정의하는 뼈대의 계층 구조입니다. 이는 애니메이션 데이터와 3D 모델을 연결하는 '청사진' 역할을 합니다. 언리얼에서 `Skeleton`은 독립적인 애셋으로, **애니메이션 공유의 핵심**입니다. 동일한 `Skeleton` 애셋을 사용하는 모든 캐릭터는 애니메이션을 재사용할 수 있어, 효율성을 극대화합니다.
- **`Skeletal Mesh`:** `Skeleton`에 '스키닝'된 3D 모델입니다. 즉, 각 버텍스가 어떤 뼈에 얼마나 영향을 받을지 가중치가 적용된 상태입니다. `Skeleton`이 움직이면, 그에 맞춰 `Mesh`가 변형됩니다.

#### 1.2. `Animation Sequence`: 움직임의 최소 단위
- **`Animation Sequence`:** '걷기', '점프' 등 단일 동작에 대한 뼈대의 키프레임 데이터입니다. 이는 애니메이션의 가장 기본적인 클립이며, 모든 복잡한 움직임은 이 시퀀스들을 조합하여 만들어집니다.

### 2부: 애니메이션 로직의 심장, `Anim Blueprint` (The Brain)

`Anim Blueprint`는 1부에서 준비된 재료들을 조합하여, 게임 상황에 맞는 최종 포즈를 매 프레임 계산해내는 '두뇌'입니다.

#### 2.1. `Event Graph`와 `Anim Graph`: 데이터와 로직의 분리
- **`Event Graph`:** 게임 월드로부터 데이터를 '입력'받는 역할을 전담합니다. 캐릭터의 속도, 방향, 점프 여부 등 게임플레이와 관련된 모든 변수를 이곳에서 계산하고 저장합니다.
- **`Anim Graph`:** `Event Graph`에서 받은 데이터를 사용하여, 실제 애니메이션 로직을 '처리'합니다. 이곳의 최종 결과물(`Output Pose`)이 캐릭터의 최종 포즈가 됩니다. 이처럼 데이터의 수집과 로직의 처리를 분리하는 것은 명확하고 유지보수하기 쉬운 구조를 만듭니다.

#### 2.2. `State Machine`: 상태 기반의 로직 제어
- **`State Machine`:** '지상', '공중', '수영 중' 등 캐릭터의 명확한 '상태'를 정의하고, 상태 간의 전환 조건을 관리합니다. 이는 복잡한 애니메이션 로직을 직관적으로 설계할 수 있게 해주는 핵심적인 기능입니다. 각 상태는 내부에 또 다른 로직(`Animation Sequence`, `Blend Space` 등)을 품고 있습니다.

#### 2.3. `Blend Space`: 연속적인 움직임의 창조
- **`Blend Space`:** 여러 애니메이션을 N차원(주로 1D 또는 2D) 공간에 배치하고, 특정 변수 값에 따라 부드럽게 블렌딩합니다. 이는 '서기 -> 걷기 -> 뛰기'처럼 상태가 명확히 구분되지 않는 **연속적인 움직임**을 자연스럽게 표현하기 위해 사용됩니다. `State Machine`이 '이산적인 상태'를 관리한다면, `Blend Space`는 '연속적인 상태'를 처리합니다.

### 3부: 동적인 표현과 상호작용 (Advanced Expression & Interaction)

기본적인 로직 위에, 상황에 맞는 풍부한 표현을 더하고 월드와 상호작용하기 위한 고급 기법들입니다.

#### 3.1. `Animation Montage`: 우선권을 가진 특별한 움직임
- **`Animation Montage`:** `State Machine`의 현재 상태와 관계없이, 특정 애니메이션(공격, 재장전, 스킬 시전 등)을 '우선적으로' 재생시키는 시스템입니다. 이는 일반적인 상태 흐름을 잠시 중단하고 특별한 액션을 수행해야 할 때 사용됩니다. 몽타주 내의 **`Notify`**는 애니메이션의 특정 지점에서 사운드, 이펙트, 게임플레이 이벤트(예: 데미지 판정)를 발생시키는 강력한 동기화 도구입니다.

#### 3.2. `Root Motion`: 애니메이션 주도의 이동
- **`Root Motion`:** 캐릭터의 이동을 코드가 아닌, 애니메이션 데이터 자체가 제어하도록 하는 기능입니다. 루트 뼈대의 움직임을 실제 월드 이동에 적용하여, 발이 미끄러지는 현상 없이 묵직하고 사실적인 움직임을 구현합니다. 이는 캐릭터의 움직임이 '애니메이션에 의해 주도'되도록 하여, 시각적 퀄리티를 극대화합니다.

#### 3.3. `Control Rig`과 `IK`: 절차적 월드 상호작용
- **`Control Rig` & `IK` (Inverse Kinematics):** 미리 만들어진 애니메이션을 재생하는 것을 넘어, 런타임에 절차적으로(Procedurally) 캐릭터를 제어하는 기술입니다.
    - **`IK`:** 손이나 발과 같은 끝단(`End-effector`)의 목표 위치를 지정하면, 그에 맞게 부모 뼈들이 자동으로 계산되어 포즈를 취합니다. 이를 통해 울퉁불퉁한 지형에 자연스럽게 발을 딛거나, 벽에 손을 짚는 등 **환경과의 동적인 상호작용**을 구현할 수 있습니다.
    - **`Control Rig`:** `IK`를 포함한 다양한 절차적 애니메이션 로직을 노드 기반으로 구현할 수 있는 강력한 시스템입니다.

### 결론: 유기적인 아키텍처

언리얼 엔진의 애니메이션 시스템은 단순 기능의 나열이 아닙니다. **`Skeleton`**을 중심으로 데이터를 공유하고, **`Anim Blueprint`**가 게임 월드와 소통하며 로직을 처리하고, **`Montage`**와 **`IK`** 등의 고급 기법을 통해 풍부한 표현을 더하는, 매우 체계적이고 유기적인 아키텍처로 설계되어 있습니다. 이 구조를 이해하는 것이야말로, 언리얼 엔진으로 생동감 넘치는 캐릭터를 창조하는 첫걸음입니다.