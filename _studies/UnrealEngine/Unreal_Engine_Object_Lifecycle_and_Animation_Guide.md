---
In: UnrealEngine
title: "Unreal Engine Object Lifecycle and Animation Guide"
author: "Gemini"
---

# Unreal Engine: Object Lifecycle and Animation Guide

언리얼 엔진에서 살아 숨 쉬는 캐릭터를 만들기 위해서는, 그 기반이 되는 오브젝트 시스템의 작동 방식을 이해하는 것이 필수적입니다. 모든 것은 가장 기본적인 `UObject`에서 시작하여, 월드에 존재하는 `Actor`와 그 기능을 확장하는 `Component`로 구체화됩니다. 그리고 이 구조 위에서 비로소 `Animation` 시스템이 동작하여 캐릭터에 생명을 불어넣습니다.

이 가이드는 언리얼의 가장 근본적인 오브젝트 생명주기(Lifecycle)부터 시작하여, 최종적으로 애니메이션 시스템이 어떻게 유기적으로 결합되는지 그 전체적인 아키텍처를 심도 있게 탐구합니다.

## 1부: 모든 것의 근원, UObject와 생명주기

`UObject`는 언리얼 엔진의 모든 클래스의 최상위 기본 클래스입니다. 이는 다음과 같은 핵심 시스템의 기반을 제공합니다.

- **리플렉션(Reflection)**: 런타임에 클래스의 속성과 함수를 동적으로 파악하고 조작합니다.
- **가비지 컬렉션(Garbage Collection)**: 더 이상 참조되지 않는 `UObject`의 메모리를 자동으로 해제합니다.
- **시리얼라이제이션(Serialization)**: 오브젝트의 상태를 디스크에 저장하거나 네트워크로 전송합니다.

### UObject 라이프사이클

1.  **생성(Creation)**: `NewObject<UYourClass>()` 등을 통해 인스턴스화됩니다.
2.  **초기화(Initialization)**: `PostInitProperties()`(속성 초기화 후), `PostLoad()`(디스크에서 로드 후) 등이 호출됩니다.
3.  **소멸(Destruction)**: 아무 곳에서도 참조되지 않으면 가비지 컬렉터에 의해 수집됩니다. `BeginDestroy()`가 호출되어 소멸 과정을 시작하고, `FinishDestroy()`로 마무리됩니다.

## 2부: 월드의 구성 단위, Actor와 Component

`Actor`와 `Component`는 `UObject`를 상속받아 게임 월드를 구성하는 실질적인 단위입니다.

- **`AActor`**: 월드에 배치될 수 있는 독립적인 개체입니다. 고유한 위치, 회전, 크기(`Transform`)를 가집니다. 캐릭터, 아이템, 광원 등 월드에 존재하는 모든 것이 액터입니다.
- **`UActorComponent`**: 액터에 부착되어 특정 기능(모양, 움직임, 능력 등)을 제공하는 모듈식 부품입니다. 컴포넌트는 재사용이 가능하여 효율적인 개발을 돕습니다.

### Actor와 Component의 라이프사이클

액터의 생명주기는 `UObject`보다 더 구체적이며, 게임플레이와 밀접하게 연관됩니다. 컴포넌트는 자신을 소유한 액터의 라이프사이클에 종속됩니다.

| 단계 | 주요 함수 (호출 순서) | 역할 및 설명 |
| --- | --- | --- |
| **생성/스폰** | `OnConstruction` | 액터가 생성될 때(에디터, 런타임) 호출됩니다. 블루프린트의 생성자 스크립트가 실행되는 시점입니다. |
| **초기화** | `PreInitializeComponents` | 컴포넌트들이 초기화되기 직전에 호출됩니다. |
| | `InitializeComponent` | 각 **컴포넌트**가 스스로를 초기화하는 함수입니다. |
| | `PostInitializeComponents` | 모든 컴포넌트의 초기화가 완료된 후 호출됩니다. 컴포넌트 간의 참조 설정에 유용합니다. |
| | **`BeginPlay`** | **가장 중요한 초기화 함수.** 액터가 월드에 완전히 진입하여 게임플레이를 시작할 준비가 되었을 때 호출됩니다. 대부분의 게임 로직은 여기서 시작됩니다. |
| **업데이트** | **`Tick` / `TickComponent`** | 매 프레임 호출되어 시간의 흐름에 따른 로직을 처리합니다. 성능에 민감하므로 필요할 때만 사용해야 합니다. |
| **소멸** | **`EndPlay`** | 액터가 월드에서 제거되기 직전에 호출됩니다. `BeginPlay`에서 설정했던 것들을 정리(Cleanup)하는 가장 중요한 곳입니다. |
| | `Destroyed` | `EndPlay` 이후, 액터가 실제로 소멸되기 직전에 마지막으로 호출됩니다. |

## 3부: 생명을 불어넣는 기술, 애니메이션 아키텍처

애니메이션 시스템은 위에서 설명한 액터/컴포넌트 구조 위에서 동작합니다. `ACharacter`는 `SkeletalMeshComponent`를 기본으로 포함하며, 이 컴포넌트가 애니메이션 시스템의 핵심입니다.

### 애니메이션의 핵심 구성 요소

1.  **`USkeleton`**: 뼈대의 계층 구조. 애니메이션 데이터와 3D 모델을 연결하는 '청사진'이자 **애니메이션 공유의 핵심**입니다.
2.  **`USkeletalMesh`**: `USkeleton`에 스키닝된 3D 모델. 실제 눈에 보이는 캐릭터의 외형입니다.
3.  **`UAnimSequence`**: '걷기', '점프' 등 단일 동작에 대한 키프레임 데이터입니다.
4.  **`UAnimBlueprint`**: **애니메이션의 뇌.** 게임 상태에 따라 어떤 애니메이션을 어떻게 조합할지 결정하는 모든 로직의 집합체입니다.

### 애니메이션 블루프린트의 구조

애니메이션 블루프린트는 액터의 `Tick` 라이프사이클에 맞춰 매 프레임 업데이트되며, 두 개의 주요 그래프로 나뉩니다.

- **이벤트 그래프 (Event Graph)**: **데이터 입력부.** 액터의 `Tick`과 함께 `Event Blueprint Update Animation` 노드가 매 프레임 실행됩니다. 여기서 `Try Get Pawn Owner`를 통해 캐릭터의 현재 속도, 점프 여부 등 게임플레이 데이터를 가져와 변수에 저장합니다.

- **애님 그래프 (Anim Graph)**: **로직 처리부.** 이벤트 그래프에서 준비된 변수들을 사용하여, 최종적으로 캐릭터가 취할 포즈를 계산하고 조합합니다.
    - **상태 머신 (State Machines)**: '지상', '공중' 등 캐릭터의 명확한 상태를 정의하고 전환 규칙을 만듭니다.
    - **블렌드 스페이스 (Blend Spaces)**: 속도나 방향 같은 변수에 따라 여러 애니메이션(예: 서기→걷기→뛰기)을 부드럽게 섞어줍니다.
    - **애니메이션 몽타주 (Animation Montage)**: 상태 머신의 흐름과 독립적으로, 공격이나 스킬 사용처럼 우선순위가 높은 특정 애니메이션을 재생합니다.

### 전체 시스템의 유기적 결합

1.  **생성**: `ACharacter` 액터가 월드에 스폰됩니다. `OnConstruction` -> `BeginPlay` 라이프사이클이 순차적으로 실행됩니다.
2.  **초기화**: `BeginPlay`에서 캐릭터는 자신의 `SkeletalMeshComponent`에 설정된 `AnimBlueprint` 인스턴스를 가져와 참조를 저장해 둘 수 있습니다.
3.  **업데이트 (매 프레임)**:
    a. 캐릭터의 `Tick` 함수가 호출됩니다.
    b. 애니메이션 블루프린트의 **이벤트 그래프**가 업데이트되어, 캐릭터의 현재 속도 등의 변수를 최신화합니다.
    c. **애님 그래프**는 이 변수들을 사용하여 상태 머신과 블렌드 스페이스를 거쳐 최종 포즈를 계산합니다.
    d. 계산된 포즈가 `SkeletalMeshComponent`에 적용되어 화면에 렌더링됩니다.
4.  **상호작용**: 플레이어가 공격 버튼을 누르면, 캐릭터의 C++ 코드는 `AnimInstance->Montage_Play(AttackMontage)`를 호출합니다. 애님 그래프는 현재 로직을 잠시 멈추고 몽타주를 우선적으로 재생합니다.
5.  **소멸**: 캐릭터가 죽으면 `Destroy()` 함수가 호출되고, `EndPlay` 라이프사이클 이벤트가 실행되어 모든 것을 정리합니다.

이처럼 언리얼 엔진은 `UObject`라는 단단한 기반 위에 `Actor`와 `Component`라는 유연한 구조를 세우고, 그 위에서 `Animation` 시스템이 유기적으로 동작하도록 설계되어 있습니다. 이 아키텍처를 이해하는 것은 복잡하고 생동감 넘치는 캐릭터를 체계적으로 구현하는 첫걸음입니다.
