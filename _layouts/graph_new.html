---
layout: default
---
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.9.1/showdown.min.js"></script>
<script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>

<style type="text/css">
    .graph-container {
        display: flex;
        flex-direction: column;
        gap: 20px;
    }

    .graph-section {
        padding: 15px;
        border: 1px solid #333;
        border-radius: 8px;
        background: #2c2c2c;
        box-sizing: border-box;
    }

    #archive-selector {
        width: 100%;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 10px;
    }

    #graph-controls {
        padding: 10px 15px;
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 15px;
    }

    #graph-diagram {
        width: 100%;
        height: 60vh;
        text-align: center;
        color: #888;
        border-color: #444;
        overflow: hidden;
        background: #1e1e1e;
    }

    .bottom-section {
        display: flex;
        flex-wrap: nowrap;
        gap: 20px;
        width: 100%;
    }

    #document-list {
        width: 40%;
        height: 70vh;
        overflow-y: auto;
    }

    #document-content {
        width: 60%;
        height: 70vh;
        overflow-y: auto;
    }

    .archive-button {
        background: #444;
        border: 1px solid #555;
        padding: 8px 12px;
        cursor: pointer;
        border-radius: 5px;
        color: #eee;
        transition: background-color 0.2s, border-color 0.2s;
    }

    .archive-button:hover {
        background-color: #555;
        border-color: #666;
    }

    .archive-button.active {
        background: #007bff;
        color: white;
        border-color: #0056b3;
    }

    #document-list ul {
        list-style: none;
        padding: 0;
        margin: 0;
    }

    #document-list a {
        display: block;
        padding: 8px;
        text-decoration: none;
        color: #ccc;
        border-bottom: 1px solid #333;
    }

    #document-list a:hover {
        background: #383838;
    }

    #document-list a.selected {
        background: #007bff;
        color: white;
    }

    .control-group {
        display: flex;
        align-items: center;
        gap: 5px;
    }

    .control-group label {
        margin-right: 5px;
    }

    .control-group input[type="number"] {
        width: 60px;
        background-color: #333;
        color: #eee;
        border: 1px solid #555;
        border-radius: 4px;
        padding: 4px;
    }

    #regen-button {
        background: #007bff;
        color: white;
        border: none;
        padding: 5px 15px;
        border-radius: 4px;
        cursor: pointer;
    }

    #regen-button:hover {
        background: #0056b3;
    }

    /* D3 specific styles */
    .links line {
        stroke: #555555;
        stroke-opacity: 0.7;
        stroke-width: 0.8px;
        transition: stroke-opacity 0.3s ease, stroke 0.3s ease;
    }

    .nodes .node {
        transition: opacity 0.3s ease;
    }

    .nodes circle {
        stroke: #888;
        stroke-width: 1.5px;
        transition: stroke-width 0.2s ease, stroke 0.2s ease;
    }

    .nodes .node.selected circle {
        stroke: #007bff;
        stroke-width: 2.5px;
    }

    .nodes text {
        font-weight: bold;
        pointer-events: none;
        font-family: sans-serif;
        text-anchor: middle;
    }

    .nodes .node:hover {
        cursor: pointer;
    }

    .internal-link {
        color: #8ab4f8;
        text-decoration: none;
    }

    .internal-link:hover {
        text-decoration: underline;
    }

    .internal-link-broken {
        color: #ff8a80;
    }
</style>

<div class="post-content">
    <h1>Obsidian Archive Explorer</h1>
    <p>Select an archive to see the list of documents from the Obsidian vault.</p>
</div>

<div class="graph-container">
    <div id="archive-selector" class="graph-section"></div>
    <div id="graph-controls" class="graph-section" style="display: none;">
        <div class="control-group">
            <label for="node-size-input">Max Node Size:</label>
            <input type="number" id="node-size-input" min="5" max="50" step="1" value="15">
        </div>
        <div class="control-group">
            <label for="charge-strength-input">Tension:</label>
            <input type="number" id="charge-strength-input" min="-500" max="100" step="1" value="-50">
        </div>
        <button id="regen-button">Regenerate</button>
    </div>
    <div id="graph-diagram" class="graph-section">
        <p>Select an archive to display the graph.</p>
    </div>
    <div class="bottom-section">
        <div id="document-list" class="graph-section">
            <p>Select an archive first.</p>
        </div>
        <div id="document-content" class="graph-section">
            <p>Select a document to view its content.</p>
        </div>
    </div>
</div>

{%- comment -%} Collect all documents from collections {%- endcomment -%}
{%- assign all_docs = "" | split: "" -%}
{%- for doc in site.articles -%}
{%- assign all_docs = all_docs | push: doc -%}
{%- endfor -%}
{%- for doc in site.studies -%}
{%- assign all_docs = all_docs | push: doc -%}
{%- endfor -%}
{%- for doc in site.projects -%}
{%- assign all_docs = all_docs | push: doc -%}
{%- endfor -%}
{%- for doc in site.obsidian -%}
{%- assign all_docs = all_docs | push: doc -%}
{%- endfor -%}

{%- comment -%} Generate title-to-URL mapping for link resolution {%- endcomment -%}
{%- assign title_map = "" | split: "" -%}
{%- for doc in all_docs -%}
{%- if doc.title -%}
{%- assign title_key = doc.title -%}
{%- else -%}
{%- assign filename = doc.path | split: "/" | last | replace: ".md", "" -%}
{%- assign title_key = filename -%}
{%- endif -%}
{%- assign pair = title_key | append: "||" | append: doc.url -%}
{%- assign title_map = title_map | push: pair -%}
{%- endfor -%}

{%- comment -%} Generate document data and archive list {%- endcomment -%}
{%- assign docs_data = "" | split: "" -%}
{%- assign archive_list = "" | split: "" -%}
{%- for doc in all_docs -%}

{%- comment -%} Get document title {%- endcomment -%}
{%- if doc.title -%}
{%- assign doc_title = doc.title -%}
{%- else -%}
{%- assign filename = doc.path | split: "/" | last | replace: ".md", "" -%}
{%- assign doc_title = filename -%}
{%- endif -%}

{%- comment -%} Get collection name {%- endcomment -%}
{%- assign collection_name = "unknown" -%}
{%- if doc.path contains "_articles/" -%}
{%- assign collection_name = "articles" -%}
{%- elsif doc.path contains "_studies/" -%}
{%- assign collection_name = "studies" -%}
{%- elsif doc.path contains "_projects/" -%}
{%- assign collection_name = "projects" -%}
{%- elsif doc.path contains "_obsidian/" -%}
{%- assign collection_name = "obsidian" -%}
{%- endif -%}

{%- comment -%} Get archive name {%- endcomment -%}
{%- if collection_name == "obsidian" -%}
{%- assign rel_path = doc.path | remove_first: "_obsidian/" -%}
{%- if rel_path contains "/" -%}
{%- assign path_parts = rel_path | split: "/" -%}
{%- assign archive_name = path_parts[0] -%}
{%- else -%}
{%- assign archive_name = "Root" -%}
{%- endif -%}
{%- else -%}
{%- assign archive_name = collection_name -%}
{%- endif -%}

{%- comment -%} Add to archive list {%- endcomment -%}
{%- unless archive_list contains archive_name -%}
{%- assign archive_list = archive_list | push: archive_name -%}
{%- endunless -%}

{%- comment -%} Extract [[]] links from content {%- endcomment -%}
{%- assign content_links = "" | split: "" -%}
{%- assign wiki_links = doc.content | split: "[[" -%}
{%- for link_part in wiki_links offset: 1 -%}
{%- assign link_end = link_part | split: "]]" | first -%}
{%- assign clean_link = link_end | split: "|" | first | split: "#" | first | strip -%}
{%- if clean_link != "" and clean_link != doc_title -%}
{%- for title_pair in title_map -%}
{%- assign pair_parts = title_pair | split: "||" -%}
{%- if pair_parts[0] == clean_link -%}
{%- assign content_links = content_links | push: pair_parts[1] -%}
{%- break -%}
{%- endif -%}
{%- endfor -%}
{%- endif -%}
{%- endfor -%}

{%- comment -%} Create document JSON {%- endcomment -%}
{%- capture doc_data -%}
"{{ doc.url }}": {
"title": {{ doc_title | jsonify }},
"url": {{ doc.url | jsonify }},
"archive": {{ archive_name | jsonify }},
"collection": {{ collection_name | jsonify }},
"content": {{ doc.content | jsonify }},
"links": {{ content_links | jsonify }}
}
{%- endcapture -%}
{%- assign docs_data = docs_data | push: doc_data -%}
{%- endfor -%}

{%- comment -%} Sort archive list {%- endcomment -%}
{%- assign sorted_archives = archive_list | sort -%}

<script type="text/javascript">
    const allData = {
        "archives": {{ sorted_archives | jsonify }},
    "documents": { { { docs_data | join: "," } } }
};

    document.addEventListener("DOMContentLoaded", function () {
        const converter = new showdown.Converter();
        const archiveSelector = document.getElementById('archive-selector');
        const docList = document.getElementById('document-list');
        const docContent = document.getElementById('document-content');
        const graphDiagram = document.getElementById('graph-diagram');
        const graphControls = document.getElementById('graph-controls');

        // Title-based fast lookup map
        const titleToUrl = new Map();
        for (const url in allData.documents) {
            const doc = allData.documents[url];
            if (doc.title) {
                titleToUrl.set(doc.title, url);
            }
        }

        const nodeSizeInput = document.getElementById('node-size-input');
        const chargeStrengthInput = document.getElementById('charge-strength-input');
        const regenButton = document.getElementById('regen-button');

        let simulation;
        let currentNodes = [];
        let currentEdges = [];
        let selectedNode = null;

        function getClampedValue(element) {
            const value = parseFloat(element.value);
            const min = parseFloat(element.min);
            const max = parseFloat(element.max);
            return Math.max(min, Math.min(max, value));
        }

        function getNodeColor(node) {
            const colors = {
                articles: '#e74c3c',
                studies: '#3498db',
                projects: '#2ecc71',
                obsidian: '#9b59b6',
                other: '#95a5a6'
            };
            return colors[node.collection] || colors.other;
        }

        function drawGraph(nodes, edges) {
            graphDiagram.innerHTML = '';
            const width = graphDiagram.clientWidth;
            const height = graphDiagram.clientHeight;

            if (width === 0 || height === 0) {
                graphDiagram.innerHTML = '<p>Graph area is too small.</p>';
                return;
            }

            const svg = d3.select(graphDiagram).append("svg")
                .attr("width", width)
                .attr("height", height)
                .call(d3.zoom()
                    .scaleExtent([0.1, 3])
                    .on("zoom", (event) => {
                        container.attr("transform", event.transform);
                    }));

            const container = svg.append("g");

            // Create node map
            const nodeMap = new Map(nodes.map(node => [node.id, node]));

            // Create and validate links
            const links = edges.map(edge => ({
                source: nodeMap.get(edge.from),
                target: nodeMap.get(edge.to)
            })).filter(l => l.source && l.target);

            // Calculate connection degrees
            const degrees = new Map();
            nodes.forEach(node => degrees.set(node.id, 0));
            links.forEach(link => {
                const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                const targetId = typeof link.target === 'object' ? link.target.id : link.target;
                degrees.set(sourceId, (degrees.get(sourceId) || 0) + 1);
                degrees.set(targetId, (degrees.get(targetId) || 0) + 1);
            });

            nodes.forEach(node => {
                node.degree = degrees.get(node.id) || 0;
            });

            // Size scale
            const minDegree = d3.min(nodes, d => d.degree) || 0;
            const maxDegree = d3.max(nodes, d => d.degree) || 1;
            const sizeScale = d3.scaleSqrt()
                .domain([minDegree, maxDegree])
                .range([8, getClampedValue(nodeSizeInput)]);

            // Force simulation setup
            simulation = d3.forceSimulation(nodes)
                .force("link", d3.forceLink(links)
                    .id(d => d.id)
                    .distance(100)
                    .strength(0.3))
                .force("charge", d3.forceManyBody()
                    .strength(getClampedValue(chargeStrengthInput))
                    .distanceMax(400))
                .force("center", d3.forceCenter(width / 2, height / 2))
                .force("collision", d3.forceCollide()
                    .radius(d => sizeScale(d.degree) + 5));

            // Render links
            const link = container.append("g")
                .attr("class", "links")
                .selectAll("line")
                .data(links)
                .enter().append("line")
                .attr("stroke", "#666")
                .attr("stroke-opacity", 0.6)
                .attr("stroke-width", 1.5);

            // Create node groups
            const node = container.append("g")
                .attr("class", "nodes")
                .selectAll("g")
                .data(nodes)
                .enter().append("g")
                .attr("class", "node")
                .call(d3.drag()
                    .on("start", dragstarted)
                    .on("drag", dragged)
                    .on("end", dragended));

            // Add node circles
            const circles = node.append("circle")
                .attr("r", d => sizeScale(d.degree))
                .attr("fill", d => getNodeColor(d))
                .attr("stroke", "#fff")
                .attr("stroke-width", 2)
                .style("filter", "drop-shadow(2px 2px 4px rgba(0,0,0,0.3))")
                .on("mouseover", showTooltip)
                .on("mouseout", hideTooltip)
                .on("click", selectNode);

            // Add node labels
            const labels = node.append("text")
                .text(d => d.label.length > 15 ? d.label.substring(0, 15) + '...' : d.label)
                .attr("dy", d => sizeScale(d.degree) + 16)
                .attr("text-anchor", "middle")
                .style("font-size", "12px")
                .style("font-weight", "500")
                .style("fill", "#333")
                .style("pointer-events", "none");

            // Simulation tick event
            simulation.on("tick", () => {
                link
                    .attr("x1", d => d.source.x)
                    .attr("y1", d => d.source.y)
                    .attr("x2", d => d.target.x)
                    .attr("y2", d => d.target.y);

                node.attr("transform", d => `translate(${d.x},${d.y})`);
            });

            // Auto stop
            setTimeout(() => simulation.stop(), 8000);

            // Event handlers
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }

            function showTooltip(event, d) {
                const tooltip = d3.select('body').append('div')
                    .attr('class', 'graph-tooltip')
                    .style('opacity', 0)
                    .style('position', 'absolute')
                    .style('background', 'rgba(0,0,0,0.8)')
                    .style('color', 'white')
                    .style('padding', '10px')
                    .style('border-radius', '5px')
                    .style('font-size', '14px')
                    .style('pointer-events', 'none')
                    .style('z-index', '1000');

                tooltip.html(`
          <strong>${d.title}</strong><br>
          Collection: ${d.collection}<br>
          Connections: ${d.degree}
      `)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY - 10) + 'px')
                    .transition()
                    .duration(200)
                    .style('opacity', 1);
            }

            function hideTooltip() {
                d3.selectAll('.graph-tooltip').remove();
            }

            function selectNode(event, d) {
                selectedNode = d;

                // Clear previous selection
                circles.attr('stroke', '#fff').attr('stroke-width', 2);

                // Select new node
                d3.select(event.currentTarget).attr('stroke', '#ff6b35').attr('stroke-width', 4);

                // Highlight connections
                highlightConnections(d);

                // Render document content
                renderDocumentContent(d.id);
            }

            function highlightConnections(node) {
                // Fade all links
                link.attr('stroke-opacity', 0.1).attr('stroke-width', 1);

                // Fade all nodes  
                circles.attr('fill-opacity', 0.3);

                // Find connected links and nodes
                const connectedNodes = new Set([node.id]);

                links.forEach(link => {
                    const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
                    const targetId = typeof link.target === 'object' ? link.target.id : link.target;

                    if (sourceId === node.id || targetId === node.id) {
                        connectedNodes.add(sourceId);
                        connectedNodes.add(targetId);
                    }
                });

                // Highlight connected links
                link.filter(l => {
                    const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                    const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                    return sourceId === node.id || targetId === node.id;
                })
                    .attr('stroke-opacity', 1)
                    .attr('stroke-width', 3)
                    .attr('stroke', '#ff6b35');

                // Highlight connected nodes
                circles.filter(d => connectedNodes.has(d.id))
                    .attr('fill-opacity', 1);
            }

            // Control update functions
            function updateForces() {
                if (!simulation) return;

                const newSizeScale = d3.scaleSqrt()
                    .domain(d3.extent(simulation.nodes(), d => d.degree))
                    .range([8, getClampedValue(nodeSizeInput)]);

                circles.attr("r", d => newSizeScale(d.degree));
                labels.attr("dy", d => newSizeScale(d.degree) + 16)
                    .style("font-size", d => `${Math.max(8, newSizeScale(d.degree) / 2)}px`);

                simulation.force("collision").radius(d => newSizeScale(d.degree) + 5);
                simulation.force("charge").strength(getClampedValue(chargeStrengthInput));
                simulation.alpha(0.3).restart();
            }

            // Connect control events
            nodeSizeInput.oninput = updateForces;
            chargeStrengthInput.oninput = updateForces;

            // Clear selection on empty space click
            svg.on('click', (event) => {
                if (event.target === svg.node()) {
                    clearSelection();
                }
            });

            function clearSelection() {
                selectedNode = null;
                circles.attr('stroke', '#fff').attr('stroke-width', 2).attr('fill-opacity', 1);
                link.attr('stroke-opacity', 0.6).attr('stroke-width', 1.5).attr('stroke', '#666');
            }
        }

        function generateNodesAndEdges(data) {
            const nodes = [];
            const edges = [];

            for (const url in data.documents) {
                const doc = data.documents[url];

                nodes.push({
                    id: url,
                    label: doc.title || url.split('/').pop(),
                    title: doc.title || url.split('/').pop(),
                    collection: doc.collection || 'other',
                    degree: 0 // Will be calculated later
                });
            }

            // Title-based link detection
            for (const url in data.documents) {
                const doc = data.documents[url];
                const content = doc.content || '';

                // Detect [[ ]] internal links
                const linkMatches = content.match(/\[\[([^\]]+)\]\]/g) || [];

                linkMatches.forEach(match => {
                    const linkText = match.slice(2, -2).trim(); // Extract text from [[...]]
                    const targetUrl = titleToUrl.get(linkText);

                    if (targetUrl && targetUrl !== url) {
                        edges.push({
                            from: url,
                            to: targetUrl,
                            type: 'internal'
                        });
                    }
                });

                // Detect markdown links for internal references [text](url)
                const mdLinkMatches = content.match(/\[([^\]]+)\]\(([^)]+)\)/g) || [];

                mdLinkMatches.forEach(match => {
                    const parts = match.match(/\[([^\]]+)\]\(([^)]+)\)/);
                    if (parts && parts[2]) {
                        const linkUrl = parts[2].trim();

                        // Check if it's a relative or internal link
                        if (!linkUrl.startsWith('http') && !linkUrl.startsWith('#')) {
                            // Try title matching with link text
                            const linkText = parts[1].trim();
                            const targetUrl = titleToUrl.get(linkText);

                            if (targetUrl && targetUrl !== url) {
                                edges.push({
                                    from: url,
                                    to: targetUrl,
                                    type: 'markdown'
                                });
                            }
                        }
                    }
                });
            }

            return { nodes, edges };
        }

        function renderDocumentContent(selectedUrl) {
            if (!selectedUrl || !allData.documents[selectedUrl]) {
                docContent.innerHTML = '<p>Please select a document.</p>';
                return;
            }

            const doc = allData.documents[selectedUrl];
            const htmlContent = converter.makeHtml(doc.content || 'No content available.');

            docContent.innerHTML = `
    <div class="document-header">
      <h2>${doc.title || 'Untitled'}</h2>
      <div class="document-meta">
        <span class="collection-badge collection-${doc.collection}">${doc.collection || 'other'}</span>
        <span class="date">${doc.date || ''}</span>
      </div>
    </div>
    <div class="document-body">
      ${htmlContent}
    </div>
  `;

            // Make document links clickable
            const links = docContent.querySelectorAll('a[href]');
            links.forEach(link => {
                const href = link.getAttribute('href');

                // Handle internal links
                if (!href.startsWith('http') && !href.startsWith('#')) {
                    link.addEventListener('click', (e) => {
                        e.preventDefault();

                        // Find document by href or link text
                        const targetUrl = titleToUrl.get(href) || titleToUrl.get(link.textContent);
                        if (targetUrl) {
                            renderDocumentContent(targetUrl);

                            // Select corresponding node in graph
                            const targetNode = currentNodes.find(n => n.id === targetUrl);
                            if (targetNode) {
                                selectNodeProgrammatically(targetNode);
                            }
                        }
                    });
                }
            });
        }

        function selectNodeProgrammatically(node) {
            selectedNode = node;

            // Find and visually select the node in SVG
            d3.selectAll('.node circle').attr('stroke', '#fff').attr('stroke-width', 2);
            d3.selectAll('.node circle').filter(d => d.id === node.id)
                .attr('stroke', '#ff6b35').attr('stroke-width', 4);

            // Highlight connections
            highlightConnections(node);
        }

        function updateArchiveList() {
            const selectedArchive = document.querySelector('.archive-button.active')?.textContent || 'all';

            if (selectedArchive === 'all') {
                currentNodes = [];
                currentEdges = [];
                const generated = generateNodesAndEdges(allData);
                currentNodes = generated.nodes;
                currentEdges = generated.edges;
            } else {
                const filteredData = {
                    documents: {}
                };

                for (const url in allData.documents) {
                    const doc = allData.documents[url];
                    if (doc.archive === selectedArchive) {
                        filteredData.documents[url] = doc;
                    }
                }

                const generated = generateNodesAndEdges(filteredData);
                currentNodes = generated.nodes;
                currentEdges = generated.edges;
            }

            // Update document list
            docList.innerHTML = '<h3>Documents</h3><ul></ul>';
            const ul = docList.querySelector('ul');
            currentNodes.forEach(node => {
                const li = document.createElement('li');
                const a = document.createElement('a');
                a.href = '#';
                a.textContent = node.title;
                a.addEventListener('click', (e) => {
                    e.preventDefault();
                    renderDocumentContent(node.id);
                    selectNodeProgrammatically(node);

                    // Update selected state in document list
                    docList.querySelectorAll('a').forEach(link => link.classList.remove('selected'));
                    a.classList.add('selected');
                });
                li.appendChild(a);
                ul.appendChild(li);
            });

            // Redraw graph
            drawGraph(currentNodes, currentEdges);
            graphControls.style.display = currentNodes.length > 0 ? 'flex' : 'none';
        }

        // Regeneration button event
        regenButton.addEventListener('click', () => {
            if (simulation) {
                simulation.alpha(1).restart();
                setTimeout(() => simulation.stop(), 8000);
            }
        });

        // Initialize archive selector buttons
        function initializeArchiveSelector() {
            archiveSelector.innerHTML = '<label>Select Archive:</label>';

            // Add "All" button
            const allButton = document.createElement('button');
            allButton.className = 'archive-button active';
            allButton.textContent = 'all';
            allButton.addEventListener('click', () => {
                document.querySelectorAll('.archive-button').forEach(btn => btn.classList.remove('active'));
                allButton.classList.add('active');
                updateArchiveList();
            });
            archiveSelector.appendChild(allButton);

            // Add archive-specific buttons
            allData.archives.forEach(archive => {
                const button = document.createElement('button');
                button.className = 'archive-button';
                button.textContent = archive;
                button.addEventListener('click', () => {
                    document.querySelectorAll('.archive-button').forEach(btn => btn.classList.remove('active'));
                    button.classList.add('active');
                    updateArchiveList();
                });
                archiveSelector.appendChild(button);
            });
        }

        // Initial load
        initializeArchiveSelector();
        updateArchiveList();
    });
</script>