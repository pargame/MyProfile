---
title: "[Unreal] 아키텍처: 컨트롤러와 캐릭터, 그 책임의 경계"
date: 2025-08-04 16:27:00 +0900
categories: Unreal
author: Gemini
---

> 이 문서는 언리얼 엔진의 게임플레이 프레임워크에 대한 기술적인 대화를 재구성하고 정리한 것입니다. `UPROPERTY`와 같은 저수준의 변수 관리부터 `AController`와 `ACharacter`의 관계, 그리고 전체 아키텍처의 설계 철학에 이르기까지, 개발자가 흔히 가질 수 있는 깊이 있는 질문과 그에 대한 답변을 중심으로 내용을 전개합니다.

## 1. 변수 관리와 리플렉션: UPROPERTY의 역할

#### Q: `UPROPERTY`와 C++ 접근 지정자(`public`, `protected`, `private`)는 어떤 순서로 결정해야 하나요?

**A:** "접근 지정자를 먼저 결정하고, 그 후에 `UPROPERTY`를 결정한다"는 순서는 실용적인 접근법입니다. 핵심은 두 시스템이 서로 다른 목적을 가지고 독립적으로 작동한다는 점입니다.

- **C++ 접근 지정자**: C++ 코드 수준에서의 캡슐화(Encapsulation)를 담당합니다. 다른 C++ 클래스가 변수에 직접 접근할 수 있는지 결정합니다.
- **`UPROPERTY` 매크로**: 언리얼 엔진의 리플렉션(Reflection) 시스템에 변수를 노출시키는 역할을 합니다. 가비지 컬렉션(GC), 에디터 노출, 블루프린트 접근, 직렬화, 네트워크 리플리케이션 등 엔진의 고유 기능에 변수를 참여시킬지 결정합니다.

#### Q: `private` 또는 `protected` 변수를 블루프린트나 에디터에 노출시키려면 어떻게 해야 하나요?

**A:** `public`이 아닌 멤버 변수를 엔진 시스템에 노출시키려면 `meta` 지정자를 사용해야 합니다.

- **`private`**: **반드시 `meta = (AllowPrivateAccess = "true")`** 지정자가 필요합니다. `private` 멤버는 자식 클래스조차 접근할 수 없으므로, 블루프린트나 에디터 같은 외부 시스템에서의 접근을 명시적으로 허용해줘야 합니다.
- **`protected`**: 블루프린트는 C++ 클래스의 자식 클래스로 취급되므로, C++의 상속 규칙에 따라 `protected` 멤버에 접근할 수 있습니다. 따라서 **별도의 `meta` 지정자 없이도** 블루프린트/에디터에 노출이 가능합니다.

#### Q: 댕글링 포인터(Dangling Pointer)란 무엇이며, `UPROPERTY`와 어떤 관계가 있나요?

**A:** 댕글링 포인터란 이미 해제(freed)되어 더 이상 유효하지 않은 메모리 주소를 가리키고 있는 포인터를 의미합니다.

> 언리얼 엔진의 가비지 컬렉터(GC)는 `UObject` 객체에 대한 참조를 추적하여 더 이상 사용되지 않는 객체를 메모리에서 자동으로 해제합니다. 이때 GC는 오직 **`UPROPERTY()` 매크로가 붙은 포인터만을 유효한 참조로 인식**합니다. 만약 `UObject`를 가리키는 포인터에 `UPROPERTY()`를 붙이지 않으면, GC는 해당 참조를 인지하지 못하고 객체를 임의로 해제할 수 있습니다. 그 결과, 해당 포인터는 댕글링 포인터가 되어 프로그램 충돌을 유발합니다.

## 2. 입력 처리와 책임의 위임

#### Q: 입력 바인딩은 왜 컨트롤러가 아닌 캐릭터의 `SetupPlayerInputComponent` 함수에서 정의되나요?

**A:** 이는 소프트웨어 공학의 핵심 원칙인 **결합도 감소(Decoupling)**와 **캡슐화 강화(Encapsulation)**를 위한 의도적인 설계입니다.

> 만약 컨트롤러가 모든 종류의 폰(캐릭터, 차량 등)에 대한 입력 바인딩을 직접 처리한다면, 컨트롤러는 모든 폰의 내부 구현을 알아야 하므로 결합도가 극도로 높아집니다.

언리얼 엔진은 **책임의 위임(Delegation)** 방식을 사용합니다.
1.  **컨트롤러의 역할**: 어떤 폰에 빙의하든, "이것이 너의 입력 컴포넌트이니, 여기에 너의 행동을 알아서 등록해라"라며 폰의 `SetupPlayerInputComponent` 함수를 호출하는 역할만 수행합니다.
2.  **캐릭터의 역할**: 위임받은 `InputComponent`에 자신의 행동(예: `Move`, `Jump`)과 그에 해당하는 함수를 직접 바인딩합니다.

> 결론적으로, **정보(어떻게 행동할 것인가)는 캐릭터에 있고, 주체(입력 프로세스를 시작하는)는 컨트롤러**입니다. 이를 통해 각 클래스는 자신의 책임에만 집중할 수 있어 유연성과 확장성이 극대화됩니다.

#### Q: C++의 `SetupPlayerInputComponent`와 블루프린트의 `Event On Possessed`는 어떤 차이가 있나요?

**A:** 두 함수는 각 환경에서 입력 바인딩을 위한 가장 정확하고 안전한 시점을 제공한다는 점에서 거의 동일한 역할을 합니다.

- **`SetupPlayerInputComponent` (C++)**: 컨트롤러가 폰에 빙의(`Possess`)하고, 폰의 입력이 활성화될 때 엔진에 의해 직접 호출되는 가상 함수입니다.
- **`Event On Possessed` (Blueprint)**: 컨트롤러가 폰에 성공적으로 빙의했을 때 호출되는 이벤트입니다. 이 시점에서 입력 매핑 컨텍스트(IMC)를 추가하는 것이 가장 이상적입니다.

> `BeginPlay`는 폰이 컨트롤러에 빙의되었다는 보장이 없는 범용 초기화 함수이므로, 입력 설정에는 `OnPossessed`를 사용하는 것이 더 견고한 방법입니다.

## 3. 게임플레이 프레임워크의 구조와 상호작용

#### Q: 빙의(Possession)는 왜 필요한가요? 단순한 getter와 무엇이 다른가요?

**A:** 빙의는 단순한 주소 참조(getter)를 훨씬 뛰어넘는, **'제어권의 이전'과 '상태의 전환'을 포함하는 능동적인 행위**입니다. 이는 '뇌(Controller)'와 '몸(Pawn)'을 분리하는 언리얼 엔진의 핵심 설계 철학에 기반합니다.

빙의가 일어나면 다음과 같은 일들이 연쇄적으로 발생합니다.
- **양방향 관계 설정**: 컨트롤러와 폰이 서로를 인지합니다.
- **입력 시스템 활성화**: 폰의 `SetupPlayerInputComponent`가 호출되어 입력과 행동이 연결됩니다.
- **상태 변화 이벤트 호출**: `OnPossess` (컨트롤러), `OnPossessed` (폰) 이벤트가 발생하여 관련 로직을 처리할 기회를 제공합니다.
- **네트워크 동기화**: 서버가 결정한 빙의 상태가 모든 클라이언트에 복제됩니다.

> 이 구조는 스트래티지 패턴(Strategy Pattern)과 유사하며, 폰의 코드를 변경하지 않고도 제어 주체(플레이어, AI 등)를 런타임에 동적으로 교체할 수 있는 강력한 유연성을 제공합니다.

#### Q: 캐릭터, 컨트롤러 외에 다른 프레임워크 클래스들의 역할은 무엇인가요?

- **`ACharacter`**: 월드 내의 물리적 실체(몸). 이동, 애니메이션, 충돌 등 실제 행동을 실행하는 모든 로직과 데이터를 담고 있는 구현체입니다.
- **`APlayerController`**: 실제 플레이어의 입력을 처리하고, UI 관리, 입력 모드 전환 등 클라이언트 측 로직의 시작점입니다.
- **`APlayerState`**: 플레이어의 영속적인 상태(이름, 점수, 킬/데스)를 저장합니다. 폰이 죽어도 유지됩니다.
- **`AGameState`**: 게임 세션 전체의 공통 상태(남은 시간, 경기 상태, 모든 플레이어 목록)를 저장하고 모든 클라이언트에게 복제합니다.
- **`AGameMode`**: 게임의 규칙(리스폰 방식, 승리 조건 등)을 정의하고 관리합니다. **서버에만 존재**하는 권위적인 객체입니다.
- **`UGameInstance`**: 게임의 생명주기(실행~종료)와 동일하게 유지되는 단일 객체. 레벨 전환을 초월하여 데이터를 저장하거나 온라인 세션을 관리합니다.

## 4. 코드와 빌드 시스템의 이면

#### Q: 코드에 `#include`가 없는데 어떻게 `GEngine`, `Controller`, `ULocalPlayer` 같은 타입을 사용할 수 있나요?

**A:** 이는 언리얼 엔진의 빌드 시스템, 특히 **PCH(Precompiled Header)** 와 **모듈 의존성 설정** 덕분입니다.

1.  **`Build.cs` 파일**: 프로젝트의 `Source/<ModuleName>/<ModuleName>.Build.cs` 파일에는 해당 모듈이 의존하는 다른 모듈의 목록이 정의되어 있습니다.
    ```csharp
    PublicDependencyModuleNames.AddRange(new string[] { "Core", "CoreUObject", "Engine", "InputCore", "EnhancedInput" });
    ```
2.  **의존성 선언**: 위 목록에 `"Engine"` 모듈이 포함되어 있기 때문에, 우리 모듈은 `GEngine`, `ULocalPlayer` 등이 선언된 `"Engine"` 모듈의 기능에 접근할 자격을 얻습니다.
3.  **PCH의 역할**: 언리얼 빌드 툴(UBT)은 컴파일 시, PCH 파일을 모든 `.cpp` 파일의 가장 앞에 강제로 포함시킵니다. 이 PCH 파일 안에는 `"Engine"` 모듈의 핵심 헤더(`Engine.h` 등)가 이미 포함되어 있는 경우가 많습니다.

> 결론적으로, 개발자가 직접 `#include`를 작성하지 않아도, `Build.cs` 설정과 PCH 시스템에 의해 컴파일러는 이미 해당 타입들을 알고 있는 상태입니다.

## 5. 설계 결정: IMC 등록의 주체

#### Q: IMC(Input Mapping Context)는 어디서 등록해야 하나요? 캐릭터인가요, 컨트롤러인가요?

**A:** 두 방식 모두 가능하며, 각각 장단점이 있어 프로젝트의 설계에 따라 선택할 수 있습니다.

- **캐릭터에서 등록 (1인칭 템플릿 방식)**: 캐릭터의 `BeginPlay`나 `OnPossessed`에서 등록합니다. "이 캐릭터는 항상 이 IMC를 사용한다"는 의미가 강하며, 관련 로직이 캐릭터 클래스 안에 모여있어 이해하기 쉽습니다.
- **컨트롤러에서 등록 (3인칭 템플릿 방식)**: 컨트롤러의 `BeginPlay`나 `OnPossess`에서 등록합니다. "플레이어의 현재 상태에 따라 사용할 IMC를 교체한다"는 유연성을 제공합니다. 예를 들어, 평소에는 '도보 IMC'를, 차에 타면 '운전 IMC'를 컨트롤러가 설정해줄 수 있습니다.

> 일반적으로는 **컨트롤러가 IMC를 관리하는 방식이 제어의 맥락과 행동을 분리하므로 더 확장성 있는 좋은 아키텍처로 권장됩니다.**
