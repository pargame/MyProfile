---
layout: default
---
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/showdown/1.9.1/showdown.min.js"></script>
<script type="text/javascript" src="https://d3js.org/d3.v7.min.js"></script>

<style type="text/css">
  .graph-container {
    display: flex;
    flex-direction: column;
    gap: 20px;
  }

  .graph-section {
    padding: 15px;
    border: 1px solid #333;
    border-radius: 8px;
    background: #2c2c2c;
    box-sizing: border-box;
  }

  #archive-selector {
    width: 100%;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 10px;
  }

  #graph-controls {
    padding: 10px 15px;
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 15px;
  }

  #graph-diagram {
    width: 100%;
    height: 60vh;
    text-align: center;
    color: #888;
    border-color: #444;
    overflow: hidden;
    background: #1e1e1e;
  }

  .bottom-section {
    display: flex;
    flex-wrap: nowrap;
    gap: 20px;
    width: 100%;
  }

  #document-list {
    width: 40%;
    height: 70vh;
    overflow-y: auto;
  }

  #document-content {
    width: 60%;
    height: 70vh;
    overflow-y: auto;
  }

  .archive-button {
    background: #444;
    border: 1px solid #555;
    padding: 8px 12px;
    cursor: pointer;
    border-radius: 5px;
    color: #eee;
    transition: background-color 0.2s, border-color 0.2s;
  }

  .archive-button:hover {
    background-color: #555;
    border-color: #666;
  }

  .archive-button.active {
    background: #007bff;
    color: white;
    border-color: #0056b3;
  }

  #document-list ul {
    list-style: none;
    padding: 0;
    margin: 0;
  }

  #document-list a {
    display: block;
    padding: 8px;
    text-decoration: none;
    color: #ccc;
    border-bottom: 1px solid #333;
  }

  #document-list a:hover {
    background: #383838;
  }

  #document-list a.selected {
    background: #007bff;
    color: white;
  }

  .control-group {
    display: flex;
    align-items: center;
    gap: 5px;
  }

  .control-group label {
    margin-right: 5px;
  }

  .control-group input[type="number"] {
    width: 60px;
    background-color: #333;
    color: #eee;
    border: 1px solid #555;
    border-radius: 4px;
    padding: 4px;
  }

  #regen-button {
    background: #007bff;
    color: white;
    border: none;
    padding: 5px 15px;
    border-radius: 4px;
    cursor: pointer;
  }

  #regen-button:hover {
    background: #0056b3;
  }


  /* D3 specific styles */
  .links line {
    stroke: #555555;
    stroke-opacity: 0.7;
    stroke-width: 0.8px;
    transition: stroke-opacity 0.3s ease, stroke 0.3s ease;
  }

  .nodes .node {
    transition: opacity 0.3s ease;
  }

  .nodes circle {
    stroke: #888;
    stroke-width: 1.5px;
    transition: stroke-width 0.2s ease, stroke 0.2s ease;
  }

  .nodes .node.selected circle {
    stroke: #007bff;
    stroke-width: 2.5px;
  }

  .nodes text {
    font-weight: bold;
    pointer-events: none;
    font-family: sans-serif;
    text-anchor: middle;
  }

  .nodes .node:hover {
    cursor: pointer;
  }

  .internal-link {
    color: #8ab4f8;
    text-decoration: none;
  }

  .internal-link:hover {
    text-decoration: underline;
  }

  .internal-link-broken {
    color: #ff8a80;
  }
</style>

<div class="post-content">
  <h1>Obsidian Archive Explorer</h1>
  <p>Select an archive to see the list of documents from the Obsidian vault.</p>
</div>

<div class="graph-container">
  <div id="archive-selector" class="graph-section"></div>
  <div id="graph-controls" class="graph-section" style="display: none;">
    <div class="control-group">
      <label for="node-size-input">Max Node Size:</label>
      <input type="number" id="node-size-input" min="5" max="50" step="1" value="15">
    </div>
    <div class="control-group">
      <label for="charge-strength-input">Tension:</label>
      <input type="number" id="charge-strength-input" min="-500" max="100" step="1" value="-50">
    </div>
    <button id="regen-button">Regenerate</button>
  </div>
  <div id="graph-diagram" class="graph-section">
    <p>Select an archive to display the graph.</p>
  </div>
  <div class="bottom-section">
    <div id="document-list" class="graph-section">
      <p>Select an archive first.</p>
    </div>
    <div id="document-content" class="graph-section">
      <p>Select a document to view its content.</p>
    </div>
  </div>
</div>

{%- comment -%} Collect documents from obsidian collection only {%- endcomment -%}
{%- assign all_docs = site.obsidian -%}

{%- comment -%} Title-based link mapping for all documents {%- endcomment -%}
{%- assign title_to_url = "" | split: "" -%}
{%- for doc in all_docs -%}
{%- if doc.title -%}
{%- assign doc_title = doc.title -%}
{%- else -%}
{%- assign file_name = doc.path | split: "/" | last | replace: ".md", "" -%}
{%- assign doc_title = file_name -%}
{%- endif -%}
{%- assign title_pair = doc_title | append: "::" | append: doc.url -%}
{%- assign title_to_url = title_to_url | push: title_pair -%}
{%- endfor -%}

{%- comment -%} Document data generation for obsidian collection only {%- endcomment -%}
{%- assign documents_json_parts = "" | split: "" -%}
{%- for doc in all_docs -%}
{%- comment -%} All documents are from obsidian collection {%- endcomment -%}
{%- assign collection_name = "obsidian" -%}

{%- comment -%} Generate title from filename if not present {%- endcomment -%}
{%- if doc.title -%}
{%- assign doc_title = doc.title -%}
{%- else -%}
{%- assign file_name = doc.path | split: "/" | last | replace: ".md", "" -%}
{%- assign doc_title = file_name -%}
{%- endif -%}

{%- comment -%} Extract archive name (folder name for obsidian) {%- endcomment -%}
{%- assign relative_path = doc.path | remove_first: "_obsidian/" -%}
{%- if relative_path contains "/" -%}
{%- assign path_parts = relative_path | split: "/" -%}
{%- assign archive_name = path_parts.first -%}
{%- else -%}
{%- assign archive_name = "Root" -%}
{%- endif -%}

{%- comment -%} Extract [[]] links and map to titles {%- endcomment -%}
{%- assign content_parts = doc.content | split: '[[' -%}
{%- assign links_array = "" | split: "" -%}
{%- for part in content_parts offset: 1 -%}
{%- assign link_text_raw = part | split: ']]' | first | strip -%}
{%- assign link_target = link_text_raw | split: '|' | first | split: '#' | first | strip -%}
{%- if link_target != "" and link_target != doc_title -%}
{%- comment -%} Find matching URL based on title {%- endcomment -%}
{%- for title_pair in title_to_url -%}
{%- assign pair_parts = title_pair | split: "::" -%}
{%- assign target_title = pair_parts[0] -%}
{%- assign target_url = pair_parts[1] -%}
{%- if target_title == link_target -%}
{%- assign links_array = links_array | push: target_url -%}
{%- break -%}
{%- endif -%}
{%- endfor -%}
{%- endif -%}
{%- endfor -%}

{%- comment -%} Generate JSON object {%- endcomment -%}
{%- capture doc_json -%}
"{{ doc.url }}": {
"title": {{ doc_title | jsonify }},
"url": {{ doc.url | relative_url | jsonify }},
"archive": {{ archive_name | jsonify }},
"collection": {{ collection_name | jsonify }},
"content": {{ doc.content | jsonify }},
"links": {{ links_array | jsonify }}
}
{%- endcapture -%}
{%- assign documents_json_parts = documents_json_parts | push: doc_json -%}
{%- endfor -%}{%- comment -%} Archive list generation for obsidian documents only {%- endcomment -%}
{%- assign archives_temp = "" -%}
{%- for doc in all_docs -%}
{%- assign relative_path = doc.path | remove_first: "_obsidian/" -%}
{%- if relative_path contains "/" -%}
{%- assign path_parts = relative_path | split: "/" -%}
{%- assign archive_name = path_parts.first -%}
{%- else -%}
{%- assign archive_name = "Root" -%}
{%- endif -%}
{%- assign archives_temp = archives_temp | append: archive_name | append: "," -%}
{%- endfor -%}
{%- assign archives = archives_temp | split: "," | uniq | compact | sort -%}

<script type="text/javascript">
  const allData = {
    "archives": {{ archives | sort | jsonify }},
  "documents": {
    { { documents_json_parts | join: "," } }
  }
  };

  document.addEventListener("DOMContentLoaded", function () {
    const converter = new showdown.Converter();
    const archiveSelector = document.getElementById('archive-selector');
    const docList = document.getElementById('document-list');
    const docContent = document.getElementById('document-content');
    const graphDiagram = document.getElementById('graph-diagram');
    const graphControls = document.getElementById('graph-controls');

    // title 기반 빠른 조회를 위한 맵
    const titleToUrl = new Map();
    for (const url in allData.documents) {
      const doc = allData.documents[url];
      if (doc.title) {
        titleToUrl.set(doc.title, url);
      }
    }

    const nodeSizeInput = document.getElementById('node-size-input');
    const chargeStrengthInput = document.getElementById('charge-strength-input');
    const regenButton = document.getElementById('regen-button');

    let simulation;
    let currentNodes = [];
    let currentEdges = [];
    let selectedNode = null;

    function getClampedValue(element) {
      const value = parseFloat(element.value);
      const min = parseFloat(element.min);
      const max = parseFloat(element.max);
      return Math.max(min, Math.min(max, value));
    }

    function getNodeSize(node) {
      const baseSize = 8;
      const connectionBonus = Math.min(node.degree * 2, 20);
      return baseSize + connectionBonus;
    }

    function getNodeColor(node) {
      const colors = {
        articles: '#e74c3c',
        studies: '#3498db',
        projects: '#2ecc71',
        obsidian: '#9b59b6',
        other: '#95a5a6'
      };
      return colors[node.collection] || colors.other;
    }

    function drawGraph(nodes, edges) {
      graphDiagram.innerHTML = '';
      const width = graphDiagram.clientWidth;
      const height = graphDiagram.clientHeight;

      if (width === 0 || height === 0) {
        graphDiagram.innerHTML = '<p>Graph area is too small.</p>';
        return;
      }

      const svg = d3.select(graphDiagram).append("svg")
        .attr("width", width)
        .attr("height", height)
        .call(d3.zoom()
          .scaleExtent([0.1, 3])
          .on("zoom", (event) => {
            container.attr("transform", event.transform);
          }));

      const container = svg.append("g");

      // 노드 맵 생성
      const nodeMap = new Map(nodes.map(node => [node.id, node]));

      // 링크 생성 및 유효성 검사
      const links = edges.map(edge => ({
        source: nodeMap.get(edge.from),
        target: nodeMap.get(edge.to)
      })).filter(l => l.source && l.target);

      // 연결 수 계산
      const degrees = new Map();
      nodes.forEach(node => degrees.set(node.id, 0));
      links.forEach(link => {
        const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
        const targetId = typeof link.target === 'object' ? link.target.id : link.target;
        degrees.set(sourceId, (degrees.get(sourceId) || 0) + 1);
        degrees.set(targetId, (degrees.get(targetId) || 0) + 1);
      });

      nodes.forEach(node => {
        node.degree = degrees.get(node.id) || 0;
      });

      // 크기 스케일
      const minDegree = d3.min(nodes, d => d.degree) || 0;
      const maxDegree = d3.max(nodes, d => d.degree) || 1;
      const sizeScale = d3.scaleSqrt()
        .domain([minDegree, maxDegree])
        .range([8, getClampedValue(nodeSizeInput)]);

      // 시뮬레이션 설정
      simulation = d3.forceSimulation(nodes)
        .force("link", d3.forceLink(links)
          .id(d => d.id)
          .distance(100)
          .strength(0.3))
        .force("charge", d3.forceManyBody()
          .strength(getClampedValue(chargeStrengthInput))
          .distanceMax(400))
        .force("center", d3.forceCenter(width / 2, height / 2))
        .force("collision", d3.forceCollide()
          .radius(d => sizeScale(d.degree) + 5));

      // 링크 렌더링
      const link = container.append("g")
        .attr("class", "links")
        .selectAll("line")
        .data(links)
        .enter().append("line")
        .attr("stroke", "#666")
        .attr("stroke-opacity", 0.6)
        .attr("stroke-width", 1.5);

      // 노드 그룹 생성
      const node = container.append("g")
        .attr("class", "nodes")
        .selectAll("g")
        .data(nodes)
        .enter().append("g")
        .attr("class", "node")
        .call(d3.drag()
          .on("start", dragstarted)
          .on("drag", dragged)
          .on("end", dragended));

      // 노드 원 추가
      const circles = node.append("circle")
        .attr("r", d => sizeScale(d.degree))
        .attr("fill", d => getNodeColor(d))
        .attr("stroke", "#fff")
        .attr("stroke-width", 2)
        .style("filter", "drop-shadow(2px 2px 4px rgba(0,0,0,0.3))")
        .on("mouseover", showTooltip)
        .on("mouseout", hideTooltip)
        .on("click", selectNode);

      // 노드 레이블 추가
      const labels = node.append("text")
        .text(d => d.label.length > 15 ? d.label.substring(0, 15) + '...' : d.label)
        .attr("dy", d => sizeScale(d.degree) + 16)
        .attr("text-anchor", "middle")
        .style("font-size", "12px")
        .style("font-weight", "500")
        .style("fill", "#333")
        .style("pointer-events", "none");

      // 시뮬레이션 틱 이벤트
      simulation.on("tick", () => {
        link
          .attr("x1", d => d.source.x)
          .attr("y1", d => d.source.y)
          .attr("x2", d => d.target.x)
          .attr("y2", d => d.target.y);

        node.attr("transform", d => `translate(${d.x},${d.y})`);
      });

      // 자동 정지
      setTimeout(() => simulation.stop(), 8000);

      // 이벤트 핸들러
      function dragstarted(event, d) {
        if (!event.active) simulation.alphaTarget(0.3).restart();
        d.fx = d.x;
        d.fy = d.y;
      }

      function dragged(event, d) {
        d.fx = event.x;
        d.fy = event.y;
      }

      function dragended(event, d) {
        if (!event.active) simulation.alphaTarget(0);
        d.fx = null;
        d.fy = null;
      }

      function showTooltip(event, d) {
        const tooltip = d3.select('body').append('div')
          .attr('class', 'graph-tooltip')
          .style('opacity', 0)
          .style('position', 'absolute')
          .style('background', 'rgba(0,0,0,0.8)')
          .style('color', 'white')
          .style('padding', '10px')
          .style('border-radius', '5px')
          .style('font-size', '14px')
          .style('pointer-events', 'none')
          .style('z-index', '1000');

        tooltip.html(`
            <strong>${d.title}</strong><br>
            Collection: ${d.collection}<br>
            Connections: ${d.degree}
        `)
          .style('left', (event.pageX + 10) + 'px')
          .style('top', (event.pageY - 10) + 'px')
          .transition()
          .duration(200)
          .style('opacity', 1);
      }

      function hideTooltip() {
        d3.selectAll('.graph-tooltip').remove();
      }

      function selectNode(event, d) {
        selectedNode = d;

        // 이전 선택 해제
        circles.attr('stroke', '#fff').attr('stroke-width', 2);

        // 새 노드 선택
        d3.select(event.currentTarget).attr('stroke', '#ff6b35').attr('stroke-width', 4);

        // 연결 하이라이트
        highlightConnections(d);

        // 문서 내용 렌더링
        renderDocumentContent(d.id);
      }

      function highlightConnections(node) {
        // 모든 링크 흐리게
        link.attr('stroke-opacity', 0.1).attr('stroke-width', 1);

        // 모든 노드 흐리게  
        circles.attr('fill-opacity', 0.3);

        // 연결된 링크와 노드 찾기
        const connectedNodes = new Set([node.id]);

        links.forEach(link => {
          const sourceId = typeof link.source === 'object' ? link.source.id : link.source;
          const targetId = typeof link.target === 'object' ? link.target.id : link.target;

          if (sourceId === node.id || targetId === node.id) {
            connectedNodes.add(sourceId);
            connectedNodes.add(targetId);
          }
        });

        // 연결된 링크 하이라이트
        link.filter(l => {
          const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
          const targetId = typeof l.target === 'object' ? l.target.id : l.target;
          return sourceId === node.id || targetId === node.id;
        })
          .attr('stroke-opacity', 1)
          .attr('stroke-width', 3)
          .attr('stroke', '#ff6b35');

        // 연결된 노드 하이라이트
        circles.filter(d => connectedNodes.has(d.id))
          .attr('fill-opacity', 1);
      }

      // 컨트롤 업데이트 함수
      function updateForces() {
        if (!simulation) return;

        const newSizeScale = d3.scaleSqrt()
          .domain(d3.extent(simulation.nodes(), d => d.degree))
          .range([8, getClampedValue(nodeSizeInput)]);

        circles.attr("r", d => newSizeScale(d.degree));
        labels.attr("dy", d => newSizeScale(d.degree) + 16)
          .style("font-size", d => `${Math.max(8, newSizeScale(d.degree) / 2)}px`);

        simulation.force("collision").radius(d => newSizeScale(d.degree) + 5);
        simulation.force("charge").strength(getClampedValue(chargeStrengthInput));
        simulation.alpha(0.3).restart();
      }

      // 컨트롤 이벤트 연결
      nodeSizeInput.oninput = updateForces;
      chargeStrengthInput.oninput = updateForces;

      // 빈 공간 클릭 시 선택 해제
      svg.on('click', (event) => {
        if (event.target === svg.node()) {
          clearSelection();
        }
      });

      function clearSelection() {
        selectedNode = null;
        circles.attr('stroke', '#fff').attr('stroke-width', 2).attr('fill-opacity', 1);
        link.attr('stroke-opacity', 0.6).attr('stroke-width', 1.5).attr('stroke', '#666');
      }
    }

    function generateNodesAndEdges(data) {
      const nodes = [];
      const edges = [];

      for (const url in data.documents) {
        const doc = data.documents[url];

        nodes.push({
          id: url,
          label: doc.title || url.split('/').pop(),
          title: doc.title || url.split('/').pop(),
          collection: doc.collection || 'other',
          degree: 0 // 나중에 계산됨
        });
      }

      // title 기반 링크 감지
      for (const url in data.documents) {
        const doc = data.documents[url];
        const content = doc.content || '';

        // [[ ]] 형태의 내부 링크 감지
        const linkMatches = content.match(/\[\[([^\]]+)\]\]/g) || [];

        linkMatches.forEach(match => {
          const linkText = match.slice(2, -2).trim(); // [[...]] 에서 텍스트 추출
          const targetUrl = titleToUrl.get(linkText);

          if (targetUrl && targetUrl !== url) {
            edges.push({
              from: url,
              to: targetUrl,
              type: 'internal'
            });
          }
        });

        // markdown 링크에서 내부 참조 감지 [text](url)
        const mdLinkMatches = content.match(/\[([^\]]+)\]\(([^)]+)\)/g) || [];

        mdLinkMatches.forEach(match => {
          const parts = match.match(/\[([^\]]+)\]\(([^)]+)\)/);
          if (parts && parts[2]) {
            const linkUrl = parts[2].trim();

            // 상대 링크 또는 내부 링크인지 확인
            if (!linkUrl.startsWith('http') && !linkUrl.startsWith('#')) {
              // 링크 텍스트로 타이틀 매칭 시도
              const linkText = parts[1].trim();
              const targetUrl = titleToUrl.get(linkText);

              if (targetUrl && targetUrl !== url) {
                edges.push({
                  from: url,
                  to: targetUrl,
                  type: 'markdown'
                });
              }
            }
          }
        });
      }

      return { nodes, edges };
    }

    function renderDocumentContent(selectedUrl) {
      if (!selectedUrl || !allData.documents[selectedUrl]) {
        docContent.innerHTML = '<p>Please select a document.</p>';
        return;
      }

      const doc = allData.documents[selectedUrl];
      const htmlContent = converter.makeHtml(doc.content || 'No content available.');

      docContent.innerHTML = `
      <div class="document-header">
        <h2>${doc.title || 'Untitled'}</h2>
        <div class="document-meta">
          <span class="collection-badge collection-${doc.collection}">${doc.collection || 'other'}</span>
          <span class="date">${doc.date || ''}</span>
        </div>
      </div>
      <div class="document-body">
        ${htmlContent}
      </div>
    `;

      // 문서 내 링크를 클릭 가능하게 만들기
      const links = docContent.querySelectorAll('a[href]');
      links.forEach(link => {
        const href = link.getAttribute('href');

        // 내부 링크 처리
        if (!href.startsWith('http') && !href.startsWith('#')) {
          link.addEventListener('click', (e) => {
            e.preventDefault();

            // href 또는 링크 텍스트로 문서 찾기
            const targetUrl = titleToUrl.get(href) || titleToUrl.get(link.textContent);
            if (targetUrl) {
              renderDocumentContent(targetUrl);

              // 그래프에서 해당 노드 선택
              const targetNode = currentNodes.find(n => n.id === targetUrl);
              if (targetNode) {
                selectNodeProgrammatically(targetNode);
              }
            }
          });
        }
      });
    }

    function selectNodeProgrammatically(node) {
      selectedNode = node;

      // SVG에서 해당 노드 찾아서 시각적으로 선택
      d3.selectAll('.node circle').attr('stroke', '#fff').attr('stroke-width', 2);
      d3.selectAll('.node circle').filter(d => d.id === node.id)
        .attr('stroke', '#ff6b35').attr('stroke-width', 4);

      // 연결 하이라이트
      highlightConnections(node);
    }

    function updateArchiveList() {
      const selectedArchive = document.querySelector('.archive-button.active')?.textContent || 'all';

      if (selectedArchive === 'all') {
        currentNodes = [];
        currentEdges = [];
        const generated = generateNodesAndEdges(allData);
        currentNodes = generated.nodes;
        currentEdges = generated.edges;
      } else {
        const filteredData = {
          documents: {}
        };

        for (const url in allData.documents) {
          const doc = allData.documents[url];
          if (doc.archive === selectedArchive) {
            filteredData.documents[url] = doc;
          }
        }

        const generated = generateNodesAndEdges(filteredData);
        currentNodes = generated.nodes;
        currentEdges = generated.edges;
      }

      // Update document list
      docList.innerHTML = '<h3>Documents</h3><ul></ul>';
      const ul = docList.querySelector('ul');
      currentNodes.forEach(node => {
        const li = document.createElement('li');
        const a = document.createElement('a');
        a.href = '#';
        a.textContent = node.title;
        a.addEventListener('click', (e) => {
          e.preventDefault();
          renderDocumentContent(node.id);
          selectNodeProgrammatically(node);

          // Update selected state in document list
          docList.querySelectorAll('a').forEach(link => link.classList.remove('selected'));
          a.classList.add('selected');
        });
        li.appendChild(a);
        ul.appendChild(li);
      });

      // Redraw graph
      drawGraph(currentNodes, currentEdges);
      graphControls.style.display = currentNodes.length > 0 ? 'flex' : 'none';
    }

    // Regeneration button event
    regenButton.addEventListener('click', () => {
      if (simulation) {
        simulation.alpha(1).restart();
        setTimeout(() => simulation.stop(), 8000);
      }
    });

    // Initialize archive selector buttons
    function initializeArchiveSelector() {
      archiveSelector.innerHTML = '<label>Select Archive:</label>';

      // Add "All" button
      const allButton = document.createElement('button');
      allButton.className = 'archive-button active';
      allButton.textContent = 'all';
      allButton.addEventListener('click', () => {
        document.querySelectorAll('.archive-button').forEach(btn => btn.classList.remove('active'));
        allButton.classList.add('active');
        updateArchiveList();
      });
      archiveSelector.appendChild(allButton);

      // Add archive-specific buttons
      allData.archives.forEach(archive => {
        const button = document.createElement('button');
        button.className = 'archive-button';
        button.textContent = archive;
        button.addEventListener('click', () => {
          document.querySelectorAll('.archive-button').forEach(btn => btn.classList.remove('active'));
          button.classList.add('active');
          updateArchiveList();
        });
        archiveSelector.appendChild(button);
      });
    }

    // Initial load
    initializeArchiveSelector();
    updateArchiveList();
  });
</script>