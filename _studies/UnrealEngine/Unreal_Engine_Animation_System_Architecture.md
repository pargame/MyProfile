---
In: UnrealEngine
title: "Unreal Engine Animation System Architecture"
author: "Gemini"
---

# Unreal Engine Animation System Architecture

언리얼 엔진에서 캐릭터에 생명을 불어넣는 과정은 액터의 생명주기(Lifecycle)와 애니메이션 시스템의 유기적인 결합을 통해 이루어집니다. 이 두 가지 핵심 개념을 함께 이해하면, 우리는 게임 월드 속에서 캐릭터가 어떻게 생성되고, 살아 움직이며, 소멸하는지에 대한 전체적인 그림을 그릴 수 있습니다.

이 가이드에서는 언리얼 엔진의 액터 생명주기와 애니메이션 시스템 아키텍처를 통합적으로 설명하여, 더욱 깊이 있는 개발 지식을 제공하고자 합니다.

## 1부: 모든 것의 시작 - 액터와 컴포넌트의 생명주기 (Lifecycle)

캐릭터는 월드에 존재하는 하나의 **액터(Actor)**입니다. 따라서 모든 애니메이션 로직의 기반에는 액터의 생명주기가 있습니다.

액터의 생명주기는 크게 **초기화**, **업데이트**, **소멸**의 세 단계로 나뉩니다.

### 1. 초기화 (Initialization)

액터가 월드에 스폰(spawn)될 때, 정해진 순서에 따라 여러 초기화 함수가 호출됩니다.

| 함수명 | 호출 시점 및 주요 역할 |
| --- | --- |
| `OnConstruction` | **(블루프린트/C++)** 액터가 생성되고 컴포넌트가 초기화되기 전에 호출됩니다. 에디터에서 실시간 미리보기를 구현할 때 유용합니다. |
| `InitializeComponent` | **(컴포넌트 C++)** 각 컴포넌트가 스스로를 초기화합니다. |
| `PostInitializeComponents` | **(C++)** 모든 컴포넌트의 초기화가 끝난 후 호출됩니다. 컴포넌트 간의 초기 참조 설정에 사용됩니다. |
| **`BeginPlay`** | **(블루프린트/C++)** **가장 중요한 초기화 함수.** 액터가 월드에 완전히 진입했을 때 호출됩니다. 애니메이션 시스템을 포함한 대부분의 게임플레이 로직이 여기서 시작됩니다. (예: 애니메이션 블루프린트 인스턴스 저장, 초기 상태 설정) |

### 2. 업데이트 (Tick)

`BeginPlay` 이후, 액터는 매 프레임 **`Tick`** 함수를 호출하여 상태를 업데이트할 수 있습니다. 애니메이션 시스템에서는 이 `Tick` 과정이 캐릭터의 움직임을 실시간으로 반영하는 핵심 역할을 합니다.

- **`AActor::Tick`**: 액터 레벨의 로직을 처리합니다.
- **`UActorComponent::TickComponent`**: 컴포넌트 레벨의 로직을 처리합니다. 애니메이션 블루프린트의 `EventGraph` 업데이트가 여기에 해당합니다.

### 3. 소멸 (Destruction)

액터가 월드에서 제거될 때, 주로 `BeginPlay`에서 설정했던 것들을 정리하는 함수들이 호출됩니다.

| 함수명 | 호출 시점 및 주요 역할 |
| --- | --- |
| **`EndPlay`** | **(블루프린트/C++)** 액터가 제거되기 직전에 호출됩니다. `BeginPlay`에서 설정했던 타이머나 바인딩된 델리게이트를 해제하는 등, 메모리 누수를 방지하기 위한 정리 코드를 작성하는 가장 중요한 곳입니다. |
| `Destroyed` | **(C++)** `EndPlay` 이후, 액터가 실제로 소멸되기 직전에 마지막 정리 기회를 제공합니다. |

## 2부: 캐릭터에 생명 불어넣기 - 애니메이션 시스템 아키텍처

애니메이션 시스템은 액터의 생명주기 위에서 동작하며, 캐릭터의 외형과 움직임을 담당합니다.

### 핵심 구성 요소

1.  **스켈레탈 메시 (Skeletal Mesh)**: 뼈대가 있어 변형 가능한 3D 모델. 캐릭터의 시각적 외형입니다.
2.  **스켈레톤 (Skeleton)**: 스켈레탈 메시를 제어하는 뼈대 구조. 애니메이션 데이터의 호환성을 결정합니다.
3.  **애니메이션 시퀀스 (Animation Sequence)**: 걷기, 뛰기 등 단일 애니메이션 클립입니다.
4.  **애니메이션 블루프린트 (Animation Blueprint)**: 캐릭터의 '애니메이션 뇌'입니다. 게임 상태에 따라 어떤 애니메이션을 어떻게 보여줄지 결정하는 모든 로직이 담겨있습니다.

### 애니메이션 블루프린트의 두뇌: 이벤트 그래프와 애님 그래프

애니메이션 블루프린트는 두 개의 강력한 그래프를 통해 작동합니다.

#### 1. 이벤트 그래프 (Event Graph)

- **역할**: 액터의 생명주기 중 **업데이트(Tick)** 단계와 직접적으로 연결됩니다. 매 프레임 실행되어 게임 월드로부터 필요한 데이터를 가져와 변수에 저장합니다.
- **주요 로직**:
    - `Event Blueprint Update Animation` 노드가 매 프레임 호출됩니다.
    - `Try Get Pawn Owner`를 통해 이 애니메이션 블루프린트가 속한 캐릭터(액터)의 정보를 가져옵니다.
    - 캐릭터의 현재 속도, 점프 여부, 체력 등 게임플레이에 필요한 변수들을 업데이트하여 **애님 그래프**로 전달할 준비를 합니다.

#### 2. 애님 그래프 (Anim Graph)

- **역할**: 이벤트 그래프에서 업데이트된 변수들을 사용하여, 최종적으로 캐릭터가 취할 포즈(애니메이션)를 계산하고 조합합니다.
- **주요 기능**:
    - **상태 머신 (State Machines)**: 'Idle', 'Walk', 'Jump' 등 캐릭터의 주요 상태를 정의하고, 상태 간의 전환 조건을 설정합니다.
    - **블렌드 스페이스 (Blend Spaces)**: 속도나 방향과 같은 변수에 따라 여러 애니메이션(예: Idle, Walk, Run)을 부드럽게 섞어줍니다.
    - **애니메이션 몽타주 (Animation Montage)**: 상태 머신의 흐름과 독립적으로 특정 애니메이션(예: 공격, 스킬 시전)을 재생할 때 사용됩니다. 보통 C++나 블루프린트 코드에서 직접 호출하여 제어합니다.

### C++ 예시: 공격 몽타주 재생 로직

캐릭터 클래스에서 입력을 받아 공격 애니메이션 몽타주를 재생하는 코드는 생명주기와 애니메이션 시스템이 어떻게 상호작용하는지 잘 보여줍니다.

```cpp
// MyCharacter.h
UCLASS()
class AMyCharacter : public ACharacter
{
    GENERATED_BODY()

public:
    // 생성자
    AMyCharacter();

    // 공격 애니메이션 몽타주
    UPROPERTY(EditDefaultsOnly, Category = "Animation")
    UAnimMontage* AttackMontage;

protected:
    // 1. 초기화: 게임 시작 시 호출
    virtual void BeginPlay() override;

    // 입력에 바인딩될 공격 함수
    void Attack();

private:
    // 애니메이션 블루프린트 인스턴스를 저장할 변수
    UPROPERTY()
    UAnimInstance* AnimInstance;
};

// MyCharacter.cpp
void AMyCharacter::AMyCharacter()
{
    // ...
}

void AMyCharacter::BeginPlay()
{
    Super::BeginPlay();

    // BeginPlay 시점에 애니메이션 인스턴스를 한 번만 가져와 저장해두면
    // 매번 함수를 호출할 필요가 없어 효율적입니다.
    AnimInstance = GetMesh()->GetAnimInstance();
}

void AMyCharacter::Attack()
{
    // 저장해둔 AnimInstance와 Montage가 유효한지 확인합니다.
    if (AnimInstance && AttackMontage)
    {
        // 현재 다른 몽타주가 재생 중이 아닐 때만 공격 몽타주를 재생합니다.
        if (!AnimInstance->Montage_IsPlaying(AttackMontage))
        {
            AnimInstance->Montage_Play(AttackMontage, 1.0f);
        }
    }
}
```

### 전체 흐름 요약

1.  **생성**: `AMyCharacter` 액터가 월드에 스폰됩니다.
2.  **초기화**: `BeginPlay`가 호출되고, 캐릭터는 자신의 `UAnimInstance`를 찾아 변수에 저장합니다.
3.  **업데이트 (게임플레이)**:
    - 플레이어가 공격 버튼을 누르면 `Attack()` 함수가 호출됩니다.
    - `Attack()` 함수는 저장된 `AnimInstance`를 통해 `Montage_Play`를 호출합니다.
    - 애니메이션 블루프린트의 **이벤트 그래프**는 매 프레임 캐릭터의 속도나 상태를 계속 업데이트합니다.
    - **애님 그래프**는 몽타주가 재생되는 동안 기본 상태 머신 로직을 잠시 중단하고, 몽타주 애니메이션을 출력합니다.
4.  **몽타주 종료**: 몽타주 재생이 끝나면, 애님 그래프는 다시 상태 머신의 로직으로 자연스럽게 복귀하여 현재 캐릭터 상태에 맞는 애니메이션(예: Idle)을 재생합니다.
5.  **소멸**: 캐릭터가 죽거나 레벨이 종료되면 `EndPlay`가 호출되어, 설정했던 모든 것들이 안전하게 정리됩니다.

이처럼 언리얼 엔진의 아키텍처는 액터의 생명주기를 기반으로, 그 위에서 애니메이션 시스템이 유기적으로 동작하도록 설계되어 있습니다. 이 구조를 이해하면 복잡하고 생동감 넘치는 캐릭터를 더욱 체계적이고 효율적으로 구현할 수 있습니다.
